//This is the route for the generate-plan API endpoint
import { NextRequest, NextResponse } from 'next/server';
//This is the Anthropic SDK
// the anthropic-ai/sdk is a package that allows you to interact with the Anthropic API
// an sdk is a software development kit that allows you to interact with a specific API
import { Anthropic } from '@anthropic-ai/sdk';
import fs from 'fs';
import path from 'path';
import crypto from 'crypto';

// Initialize Anthropic client with API key
const apiKey = process.env.ANTHROPIC_API_KEY;
// isDevelopment is a boolean that is true if the NODE_ENV is development
const isDevelopment = process.env.NODE_ENV === 'development';

console.log('Environment:', process.env.NODE_ENV);
// environment variables are stored in the .env.local file
console.log('API Key available:', !!apiKey);
// !!apiKey is a boolean that is true if apiKey is not null or undefined
// For debugging environment variables in development
if (isDevelopment) {
  console.log('Available environment variables:', Object.keys(process.env).filter(key => !key.includes('_KEY')));
}

const getAnthropicClient = () => {
  if (!apiKey) {
    // if apiKey is not set in environment variables, throw an error
    console.error('ANTHROPIC_API_KEY is not set in environment variables');
    // throw an error with a message
    throw new Error('Missing API key for Anthropic');
  }
  
  return new Anthropic({
    // anthropic is the name of the client
    apiKey: apiKey
  });
};

// Define a mock plan for development/testing purposes when no API key is available
const mockPlan = {
  summary: "This is a mock AI plan because no API key was available. In production, this would be generated by Claude.",
  keyFeatures: [
    "User authentication and profiles",
    "Content discovery feed based on user interests",
    "Personalized news recommendations", 
    "Bookmarking and saving articles for later",
    "Sharing capabilities to social media platforms",
    "Mobile-responsive design with offline reading mode"
  ],
  techStack: [
    "React.js: For building a dynamic and responsive UI",
    "Next.js: For server-side rendering and API routes",
    "Firebase: For authentication and real-time database",
    "TailwindCSS: For rapid UI development with a clean design system",
    "NewsAPI: For fetching relevant news content",
    "Vercel: For deployment and serverless functions"
  ],
  dataSchema: [
    {
      entity: "User",
      fields: ["id", "name", "email", "preferences"],
      description: "Stores user account information and preferences"
    },
    {
      entity: "Content",
      fields: ["id", "title", "body", "authorId", "createdAt"],
      description: "Represents articles and other content items"
    }
  ],
  buildSteps: [
    {
      phase: "Planning & Setup",
      tasks: ["Define project scope", "Set up development environment", "Create repository"],
      duration: "1 week"
    },
    {
      phase: "Core Development",
      tasks: ["Implement authentication", "Build UI components", "Set up database"],
      duration: "4 weeks"
    },
    {
      phase: "Testing & Deployment",
      tasks: ["Conduct user testing", "Fix bugs", "Deploy to production"],
      duration: "2 weeks"
    }
  ],
  folderStructure: [
    "src/",
    "src/components/",
    "src/pages/",
    "src/contexts/",
    "src/lib/",
    "public/"
  ]
};

// Simple caching utilities for development
const CACHE_DIR = path.join(process.cwd(), '.cache');
const CACHE_TTL = 60 * 60 * 24 * 7; // 7 days in seconds

// Ensure cache directory exists
if (isDevelopment) {
  try {
    if (!fs.existsSync(CACHE_DIR)) {
      fs.mkdirSync(CACHE_DIR, { recursive: true });
      console.log(`Created cache directory at ${CACHE_DIR}`);
    }
  } catch (error) {
    console.warn('Failed to create cache directory:', error);
  }
}

// Generate a hash from request data to use as a cache key
const getCacheKey = (data: Record<string, unknown>): string => {
  const hash = crypto.createHash('md5').update(JSON.stringify(data)).digest('hex');
  return `plan-${hash}.json`;
};

// Check if a cached response exists and is still valid
const getCachedResponse = (cacheKey: string): string | null => {
  if (!isDevelopment) return null; // Only use cache in development
  
  const cachePath = path.join(CACHE_DIR, cacheKey);
  
  try {
    if (fs.existsSync(cachePath)) {
      const cacheStats = fs.statSync(cachePath);
      const cacheAge = (Date.now() - cacheStats.mtimeMs) / 1000; // Age in seconds
      
      if (cacheAge < CACHE_TTL) {
        console.log(`Using cached response (age: ${Math.round(cacheAge / 60)} minutes)`);
        return fs.readFileSync(cachePath, 'utf-8');
      } else {
        console.log(`Cache expired (age: ${Math.round(cacheAge / 60)} minutes)`);
      }
    }
  } catch (error) {
    console.warn('Failed to read cache:', error);
  }
  
  return null;
};

// Save a response to the cache
const saveToCache = (cacheKey: string, data: string): void => {
  if (!isDevelopment) return; // Only cache in development
  
  const cachePath = path.join(CACHE_DIR, cacheKey);
  
  try {
    fs.writeFileSync(cachePath, data, 'utf-8');
    console.log(`Saved response to cache: ${cacheKey}`);
  } catch (error) {
    console.warn('Failed to write to cache:', error);
  }
};

// Function to check if the error is an overloaded API error
function isOverloadedError(error: any): boolean {
  return (
    error?.error?.type === 'overloaded_error' || 
    error?.status === 529 || 
    error?.status === 429 ||
    (typeof error.message === 'string' && error.message.includes('overloaded'))
  );
}

//This is the POST request handler for the generate-plan API endpoint
export async function POST(request: NextRequest) {
  //This is the body of the request
  console.log("API route called: generate-plan");
  
  try {
    //This is the project data from the request
    const projectData = await request.json();
    console.log("Project data received:", JSON.stringify(projectData, null, 2));
    
    // Generate cache key from request data
    const cacheKey = getCacheKey(projectData);
    
    // Check for cached response in development mode
    if (isDevelopment) {
      const cachedResponse = getCachedResponse(cacheKey);
      if (cachedResponse) {
        console.log("Returning cached response");
        return NextResponse.json({ response: cachedResponse }, { status: 200 });
      }
    }
    
    // Check for API key first
    if (!apiKey) {
      // if apiKey is not set in environment variables, log a warning
      console.warn('ANTHROPIC_API_KEY is not set in environment variables, using mock plan for development');
      
      // In development, log more info to help debugging
      if (isDevelopment) {
        console.log('In development mode, please check:');
        console.log('1. Your .env.local file has the correct ANTHROPIC_API_KEY value');
        console.log('2. You have restarted the Next.js server after adding the key');
        console.log('3. If using npm run dev, environment variables are being loaded correctly');
      }
      
      // Convert mock plan to text format to match the Claude response
      const mockResponse = JSON.stringify(mockPlan);
      
      // Save mock response to cache
      if (isDevelopment) {
        saveToCache(cacheKey, mockResponse);
      }
      
      return NextResponse.json(
        { response: mockResponse },
        { status: 200 }
      );
    }

    // Initialize Anthropic client
    const anthropic = getAnthropicClient();

    //In a real implementation, we would validate the project data
    
    // Create a prompt for Claude based on the project data
    const systemPrompt = `You are an expert AI project planner and software architect. Your task is to create a detailed development plan for a project based on the requirements provided.

    Your plan should be realistic, insightful, and tailored to the specific project needs. It must include:

    1. A concise but detailed summary of the project that captures its essence and value proposition
    2. A list of key features that should be implemented, ordered by priority and addressing specific user needs
    3. A recommended tech stack with specific modern technologies, languages, frameworks, and tools that are well-suited for this particular project
    4. A detailed step-by-step build process with clear phases and milestones
    5. A suggested data schema with entities, fields, and relationships
    6. A recommended folder structure for organizing the codebase

    Format your response as a structured JSON object with the following keys:
    {
      "summary": "A concise summary of what this project does and its main value",
      "keyFeatures": ["Feature 1", "Feature 2", "Feature 3"],
      "techStack": ["Technology 1", "Technology 2", "Technology 3"],
      "dataSchema": [
        { 
          "entity": "Entity Name", 
          "fields": ["field1", "field2"], 
          "description": "What this entity represents" 
        }
      ],
      "buildSteps": [
        {
          "phase": "Phase name",
          "tasks": ["Task 1", "Task 2"],
          "duration": "X weeks"
        }
      ],
      "folderStructure": ["folder1/", "folder1/file1.js", "folder2/"]
    }

    IMPORTANT: Your entire response must be a single, valid, parseable JSON object with the exact structure shown above. Do not include any explanatory text, markdown formatting, or anything outside the JSON object.

    For each technology in the tech stack, provide a brief explanation of why it's appropriate.
    For the features, focus on user-centric functionality that delivers value.
    For buildSteps, create a logical sequence of tasks grouped into phases.
    For dataSchema, define the main data entities, their fields, and relationships between entities.
    For folderStructure, provide a clear, organized structure following best practices for the tech stack.
    
    Be specific and practical in your recommendations. Avoid generic advice.`;

    // Create the user message with project details
    const userMessage = `
      I need a detailed development plan for a project with the following details:
      
      Project Name: ${projectData.name}
      ${projectData.projectType ? `Project Type: ${projectData.projectType} (website/app)` : ''}
      Description: ${projectData.description}
      ${projectData.businessType ? `Business Type: ${projectData.businessType}` : ''}
      ${projectData.goals ? `Goals: ${projectData.goals}` : ''}
      Target Audience: ${projectData.targetAudience}
      ${projectData.valueProposition ? `Value Proposition: ${projectData.valueProposition}` : ''}
      User Flow: ${projectData.userFlow || 'Not specified'}
      
      Please provide a comprehensive plan that addresses these specific requirements and will help me build this project successfully.
      
      Include at least 4-6 specific features and 4-6 specific technologies in the tech stack.
      Create a detailed step-by-step build process with clear phases (planning, setup, core development, testing, deployment).
      Design a data schema with the main entities needed for this application.
      Suggest a folder structure that follows modern best practices for the tech stack.
      Be concrete and specific in all your recommendations.
      
      IMPORTANT: Your response must be a valid JSON object that matches the exact structure specified in the system prompt. Do not include any text outside the JSON object.
    `;

    console.log("Calling Anthropic API...");
    
    try {
      // Call Claude API to generate the plan - updated to match latest SDK format
      const message = await anthropic.messages.create({
        model: "claude-3-7-sonnet-20250219",
        max_tokens: 3000,
        temperature: 0.7,
        system: systemPrompt,
        messages: [
          {
            role: "user",
            content: userMessage
          }
        ]
      });

      console.log("API Response structure:", JSON.stringify({
        id: message.id,
        model: message.model,
        type: message.type,
        contentTypes: Array.isArray(message.content) 
          ? message.content.map(c => c.type) 
          : typeof message.content
      }, null, 2));

      // Extract the response text from the Anthropic API response
      let responseText = '';
      
      // Handle different response structures
      if (Array.isArray(message.content)) {
        console.log("Content is an array with length:", message.content.length);
        
        // Loop through content blocks
        for (const contentBlock of message.content) {
          console.log("Content block type:", contentBlock.type);
          
          // Extract text from text-type blocks
          if (contentBlock.type === 'text') {
            responseText += contentBlock.text;
          }
        }
      } else if (message.content && typeof message.content === 'object') {
        console.log("Content is an object with keys:", Object.keys(message.content));
        
        // Use type assertion for TypeScript
        const contentObj = message.content as Record<string, unknown>;
        if (typeof contentObj.text === 'string') {
          responseText = contentObj.text;
        }
      }
      
      if (!responseText) {
        console.error('No text content found in response');
        console.log('Full message structure:', JSON.stringify(message, null, 2));
        return NextResponse.json(
          { error: 'No text content in API response' },
          { status: 500 }
        );
      }

      console.log("Extracted response text (first 200 chars):", responseText.substring(0, 200));
      
      // Try to extract JSON from the response if it's wrapped in markdown code blocks
      let jsonResponse = responseText;
      const jsonMatch = responseText.match(/```(?:json)?([\s\S]*?)```/);
      if (jsonMatch) {
        jsonResponse = jsonMatch[1].trim();
      }
      
      try {
        // Try to parse as JSON to validate
        const parsedJson = JSON.parse(jsonResponse);
        console.log("Successfully parsed JSON response");
        
        // Cache the successful response
        if (isDevelopment) {
          saveToCache(cacheKey, JSON.stringify(parsedJson));
        }
        
        return NextResponse.json({ 
          response: JSON.stringify(parsedJson)
        });
      } catch (e) {
        console.error("Failed to parse JSON from response:", e);
        console.log("Raw response:", responseText.substring(0, 1000));
        
        // If it's not valid JSON, return the raw text
        // Also cache this response for development
        if (isDevelopment) {
          saveToCache(cacheKey, responseText);
        }
        
        return NextResponse.json({ 
          response: responseText 
        });
      }
    } catch (error) {
      console.error('Error generating AI plan:', error);
      
      // Check if this is an overloaded API error
      if (isOverloadedError(error)) {
        return NextResponse.json(
          { error: 'AI service is currently overloaded. Please try again in a few minutes.' },
          { status: 529 }
        );
      }
      
      // For other errors, we can fall back to the mock plan if in development
      if (isDevelopment) {
        console.log('Falling back to mock plan due to API error');
        const mockResponse = JSON.stringify(mockPlan);
        saveToCache(cacheKey, mockResponse);
        
        return NextResponse.json(
          { response: mockResponse, warning: 'Using mock data due to API error' },
          { status: 200 }
        );
      }
      
      return NextResponse.json(
        { error: 'Failed to generate AI plan' },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error('Error generating AI plan:', error);
    
    // Still check for overloaded errors here too
    if (isOverloadedError(error)) {
      return NextResponse.json(
        { error: 'AI service is currently overloaded. Please try again in a few minutes.' },
        { status: 529 }
      );
    }
    
    return NextResponse.json(
      { error: 'Failed to generate AI plan' },
      { status: 500 }
    );
  }
} 